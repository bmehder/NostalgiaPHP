#!/usr/bin/env php
<?php
// nphp — NostalgiaPHP tiny CLI
// Usage:
//   php nphp make:post <collection> <slug> [--title="Custom Title"] [--draft] [--template=main] [--date=YYYY-MM-DD] [--force]
//   php nphp make:page <slug> [--title="Custom Title"] [--draft] [--template=main] [--date=YYYY-MM-DD] [--force]
//   php nphp backup [--to=/absolute/path]
//   php nphp build [--out=dist] [--clean]
// Notes: place this file at the project root (next to functions.php).

// ---------- helpers ----------
function exit_help($code = 0)
{
  $help = <<<TXT
NostalgiaPHP CLI

USAGE
  php nphp make:post <collection> <slug> [options]
  php nphp make:page <slug> [options]
  php nphp backup [--to=/absolute/path]
  php nphp build [--out=dist] [--clean]

OPTIONS
  --title="Custom Title"   Set a title (defaults to slug → Title Case)
  --template=main          Front-matter template (default: main)
  --date=YYYY-MM-DD        Front-matter date (default: today in site timezone)
  --draft                  Add draft: true
  --force                  Overwrite existing file
  --to=/path               (backup) Destination directory for zip files
  --out=dist               (build) Output directory (default: dist)
  --clean                  (build) Remove output directory before building

EXAMPLES
  php nphp make:post blog hello-world
  php nphp make:post dox api-design --title="API Design Notes" --template=main
  php nphp make:page about --title="About Us"
  php nphp backup --to="/Dropbox/nosty_backups"
  php nphp build --out=public --clean

TXT;
  fwrite(STDOUT, $help);
  exit($code);
}

function parse_opts(array $argv): array
{
  $opts = ['title' => null, 'template' => 'main', 'date' => null, 'draft' => false, 'force' => false];
  foreach ($argv as $arg) {
    if ($arg === '--draft') {
      $opts['draft'] = true;
      continue;
    }
    if ($arg === '--force') {
      $opts['force'] = true;
      continue;
    }
    if (strpos($arg, '--title=') === 0) {
      $opts['title'] = substr($arg, 8);
      continue;
    }
    if (strpos($arg, '--template=') === 0) {
      $opts['template'] = substr($arg, 11);
      continue;
    }
    if (strpos($arg, '--date=') === 0) {
      $opts['date'] = substr($arg, 7);
      continue;
    }
  }
  return $opts;
}

function title_from_slug(string $slug): string
{
  $t = preg_replace('/[-_]+/', ' ', $slug);
  $t = preg_replace('/\s+/', ' ', trim($t));
  return $t === '' ? 'Untitled' : ucwords($t);
}

function load_config(): array
{
  $cfgFile = __DIR__ . '/config.php';
  if (is_file($cfgFile)) {
    $cfg = require $cfgFile;
    return is_array($cfg) ? $cfg : [];
  }
  return [];
}

function site_tz(array $cfg): string
{
  $tz = $cfg['site']['timezone'] ?? 'UTC';
  return $tz ?: 'UTC';
}

function today_ymd(string $tz): string
{
  try {
    $dt = new DateTime('now', new DateTimeZone($tz));
  } catch (Throwable $e) {
    $dt = new DateTime('now');
  }
  return $dt->format('Y-m-d');
}

function ensure_dir(string $dir): void
{
  if (!is_dir($dir) && !mkdir($dir, 0775, true) && !is_dir($dir)) {
    fwrite(STDERR, "Failed to create directory: $dir\n");
    exit(1);
  }
}

function write_static_robots(string $outDir, string $policy, ?string $absBase): void
{
  $lines = [
    'User-agent: *',
  ];

  if ($policy === 'disallow') {
    $lines[] = 'Disallow: /';
    // no sitemap line when disallowed
  } else {
    // normal allow
    $lines[] = 'Disallow: /*.md$';
    $lines[] = '';
    if ($absBase && preg_match('~^https?://~i', $absBase)) {
      $lines[] = "Sitemap: {$absBase}/sitemap.xml";
    }
  }
  $txt = implode("\n", $lines) . "\n";
  file_put_contents(rtrim($outDir, '/\\') . '/robots.txt', $txt);
}

function write_file(string $path, string $content, bool $force): void
{
  if (is_file($path) && !$force) {
    fwrite(STDERR, "Refusing to overwrite existing file: $path (use --force)\n");
    exit(1);
  }
  if (file_put_contents($path, $content) === false) {
    fwrite(STDERR, "Failed to write file: $path\n");
    exit(1);
  }
}

// ---------- backup command ----------
function parse_backup_to(array $args): ?string
{
  foreach ($args as $a) {
    if (strpos($a, '--to=') === 0) {
      return rtrim(substr($a, 5), "/\\");
    }
  }
  return null;
}

function cmd_backup(array $args): int
{
  $root = realpath(getcwd()) ?: __DIR__;
  $project = basename($root);

  // destination base
  $destBase = parse_backup_to($args);
  if (!$destBase) {
    $home = getenv('HOME');
    if (!$home && strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
      $home = rtrim(getenv('HOMEDRIVE') . getenv('HOMEPATH'), "/\\");
    }
    if (!$home)
      $home = dirname($root);
    $destBase = $home . DIRECTORY_SEPARATOR . 'nosty_backups';
  }
  $destDir = $destBase . DIRECTORY_SEPARATOR . $project;

  ensure_dir($destDir);

  if (!class_exists('ZipArchive')) {
    fwrite(STDERR, "❌ PHP ZipArchive extension is required.\n");
    return 1;
  }

  $stamp = date('Y-m-d_His');
  $zipPath = $destDir . DIRECTORY_SEPARATOR . "{$project}_{$stamp}.zip";

  $zip = new ZipArchive();
  if ($zip->open($zipPath, ZipArchive::CREATE | ZipArchive::EXCL) !== true) {
    fwrite(STDERR, "❌ Could not open zip for writing: $zipPath\n");
    return 1;
  }

  // exclude some noisy or generated dirs at the project root
  $exclude = [
    '.git',
    '.github',
    '.idea',
    '.vscode',
    'node_modules',
    'vendor',
    'dist',
    'build',
    'tmp',
    'cache',
    'storage',
  ];

  $addPath = function (string $path) use (&$addPath, $zip, $root, $exclude) {
    $path = rtrim($path, "/\\");
    $rel = ltrim(substr($path, strlen($root)), "/\\"); // '' at root

    if ($rel !== '') {
      foreach ($exclude as $ex) {
        if ($rel === $ex || strpos($rel, $ex . DIRECTORY_SEPARATOR) === 0) {
          return;
        }
      }
    }

    if (is_dir($path)) {
      if ($rel !== '')
        $zip->addEmptyDir(str_replace(DIRECTORY_SEPARATOR, '/', $rel));
      $dh = opendir($path);
      if ($dh) {
        while (($file = readdir($dh)) !== false) {
          if ($file === '.' || $file === '..')
            continue;
          $addPath($path . DIRECTORY_SEPARATOR . $file);
        }
        closedir($dh);
      }
    } elseif (is_file($path)) {
      $local = $rel !== '' ? $rel : basename($path);
      $zip->addFile($path, str_replace(DIRECTORY_SEPARATOR, '/', $local));
    }
  };

  $addPath($root);

  // tiny manifest
  $zip->addFromString('__nosty_manifest.txt', "project: $project\ncreated: " . date('c') . "\nroot: $root\n");
  $zip->close();

  fwrite(STDOUT, "✅ Backup created: $zipPath\n");
  return 0;
}

// ---------- asset fix helper ----------
function fix_relative_assets(string $html): string
{
  // Fix src/href
  $html = preg_replace_callback(
    '~\b(src|href)=([\'"])([^\'"]+)\\2~i',
    function ($m) {
      [$full, $attr, $q, $url] = $m;

      // leave absolute/data/#/rooted
      if (preg_match('~^(https?:|data:|/|#)~i', $url)) {
        return $full;
      }

      // normalize
      if (strpos($url, 'static/') === 0) {
        $url = '/' . $url;
      } elseif (strpos($url, './static/') === 0) {
        $url = '/' . substr($url, 2);
      } elseif (strpos($url, '../static/') === 0) {
        $url = '/' . preg_replace('~^(\.\./)+~', '', $url);
      }

      return $attr . '=' . $q . $url . $q;
    },
    $html
  );

  // Fix srcset
  $html = preg_replace_callback(
    '~\bsrcset=([\'"])([^\'"]+)\\1~i',
    function ($m) {
      $q = $m[1];
      $candidates = array_map('trim', explode(',', $m[2]));
      $fixed = [];

      foreach ($candidates as $cand) {
        if ($cand === '')
          continue;
        [$u, $d] = array_pad(preg_split('/\s+/', $cand, 2), 2, '');
        if (!preg_match('~^(https?:|data:|/|#)~i', $u)) {
          if (strpos($u, 'static/') === 0) {
            $u = '/' . $u;
          } elseif (strpos($u, './static/') === 0) {
            $u = '/' . substr($u, 2);
          } elseif (strpos($u, '../static/') === 0) {
            $u = '/' . preg_replace('~^(\.\./)+~', '', $u);
          }
        }
        $fixed[] = trim($u . ($d ? " $d" : ''));
      }

      return 'srcset=' . $q . implode(', ', $fixed) . $q;
    },
    $html
  );

  return $html;
}

// ---------- entry ----------
array_shift($argv); // drop script name
$cmd = $argv[0] ?? '';
if ($cmd === '' || $cmd === 'help' || $cmd === '-h' || $cmd === '--help')
  exit_help(0);

$cfg = load_config();
date_default_timezone_set(site_tz($cfg));

// Commands
if ($cmd === 'make:post') {
  if (count($argv) < 3)
    exit_help(1);
  $collection = $argv[1];
  $slug = $argv[2];

  // collect options from remaining args
  $opts = parse_opts(array_slice($argv, 3));
  $title = $opts['title'] ?: title_from_slug($slug);
  $template = $opts['template'] ?: 'main';
  $date = $opts['date'] ?: today_ymd(site_tz($cfg));
  $draft = $opts['draft'];
  $force = $opts['force'];

  $collectionsPath = $cfg['paths']['collections'] ?? (__DIR__ . '/content/collections');
  $targetDir = rtrim($collectionsPath, '/\\') . '/' . $collection;
  ensure_dir($targetDir);
  $file = $targetDir . '/' . $slug . '.md';

  $front = "---\n"
    . "title: " . $title . "\n"
    . "description: \n"
    . "date: " . $date . "\n"
    . "template: " . $template . "\n"
    . "tags: \n"
    . ($draft ? "draft: true\n" : '')
    . "---\n\n"
    . "# " . $title . "\n\n"
    . "Write something great.\n";

  write_file($file, $front, $force);
  fwrite(STDOUT, "Created: $file\n");
  exit(0);
}

if ($cmd === 'make:page') {
  if (count($argv) < 2)
    exit_help(1);
  $slug = $argv[1];

  $opts = parse_opts(array_slice($argv, 2));
  $title = $opts['title'] ?: title_from_slug($slug);
  $template = $opts['template'] ?: 'main';
  $date = $opts['date'] ?: today_ymd(site_tz($cfg));
  $draft = $opts['draft'];
  $force = $opts['force'];

  $pagesPath = $cfg['paths']['pages'] ?? (__DIR__ . '/content/pages');
  $targetDir = rtrim($pagesPath, '/\\') . '/' . $slug;
  ensure_dir($targetDir);
  $file = $targetDir . '/index.md';

  $front = "---\n"
    . "title: " . $title . "\n"
    . "description: \n"
    . "date: " . $date . "\n"
    . "template: " . $template . "\n"
    . ($draft ? "draft: true\n" : '')
    . "---\n\n"
    . "# " . $title . "\n\n"
    . "Content goes here.\n";

  write_file($file, $front, $force);
  fwrite(STDOUT, "Created: $file\n");
  exit(0);
}

if ($cmd === 'backup') {
  $args = array_slice($argv, 1);
  exit(cmd_backup($args));
}

// ---------- SSG helpers ----------
function render_to_string(callable $fn)
{
  ob_start();
  $fn();
  return ob_get_clean();
}

function write_html_pretty(string $outDir, string $path, string $html)
{
  // Map URL path → disk path (pretty URLs)
  // "/"           -> dist/index.html
  // "/about"      -> dist/about/index.html
  // "/blog/slug"  -> dist/blog/slug/index.html
  $path = '/' . ltrim($path, '/');
  $target = rtrim($outDir, '/\\');

  if ($path === '/' || $path === '') {
    $file = $target . '/index.html';
  } else {
    $file = $target . rtrim($path, '/') . '/index.html';
  }

  $dir = dirname($file);
  if (!is_dir($dir)) {
    mkdir($dir, 0775, true);
  }
  if (file_put_contents($file, $html) === false) {
    fwrite(STDERR, "Failed to write: $file\n");
    exit(1);
  }
  fwrite(STDOUT, "✓ $path  ->  $file\n");
}

function copy_dir_recursive($src, $dst)
{
  if (!is_dir($src))
    return;
  if (!is_dir($dst))
    mkdir($dst, 0775, true);
  $it = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($src, FilesystemIterator::SKIP_DOTS),
    RecursiveIteratorIterator::SELF_FIRST
  );
  foreach ($it as $file) {
    $rel = substr($file->getPathname(), strlen($src));
    $to = rtrim($dst, '/\\') . $rel;
    if ($file->isDir()) {
      if (!is_dir($to))
        mkdir($to, 0775, true);
    } else {
      copy($file->getPathname(), $to);
    }
  }
}

// ---------- SSG: sitemap ----------
function build_sitemap(string $outDir, bool $includeCollectionIndexes = false): void
{
  require_once __DIR__ . '/functions.php';

  // Require an absolute base_url for correct <loc> values during SSG
  $base = (string) (config()['site']['base_url'] ?? '');
  $isAbs = (bool) preg_match('~^https?://~i', $base);
  if (!$isAbs) {
    // Fallback: trim to avoid accidental '//' joins; this will still create absolute-looking locs
    // but you really should set an absolute base_url in config for production sitemaps.
    $base = rtrim($base, '/');
  } else {
    $base = rtrim($base, '/');
  }

  $xmlEsc = static fn(string $s) =>
    htmlspecialchars($s, ENT_QUOTES | ENT_XML1, 'UTF-8');

  $abs = fn(string $path): string => $base . '/' . ltrim($path, '/');

  $entries = [];

  // ---- Pages (supports nested folders with index.md) ----
  $pagesRoot = rtrim(path('pages'), '/');
  if (is_dir($pagesRoot)) {
    $it = new RecursiveIteratorIterator(
      new RecursiveDirectoryIterator($pagesRoot, FilesystemIterator::SKIP_DOTS)
    );
    $seen = [];
    foreach ($it as $f) {
      if (!$f->isFile())
        continue;
      if (strtolower($f->getExtension()) !== 'md')
        continue;

      $full = $f->getPathname();
      $rel = trim(str_replace($pagesRoot, '', $full), '/'); // e.g. "about/index.md" or "index.md"
      $rel = preg_replace('/\.md$/i', '', $rel);

      // map .../index -> ...
      if ($rel === 'index')
        $rel = '';
      if (substr($rel, -6) === '/index')
        $rel = substr($rel, 0, -6);

      // de-dupe
      if (isset($seen[$rel]))
        continue;
      $seen[$rel] = true;

      // Figure actual file path for this URL
      $file = ($rel === '')
        ? $pagesRoot . '/index.md'
        : (is_file($pagesRoot . '/' . $rel . '.md')
          ? $pagesRoot . '/' . $rel . '.md'
          : $pagesRoot . '/' . $rel . '/index.md');

      if (!is_file($file))
        continue;

      [$fm] = parse_front_matter(read_file($file) ?? '');
      if (!empty($fm['draft']))
        continue;
      if (array_key_exists('sitemap', $fm) && $fm['sitemap'] === false)
        continue;

      $loc = $rel === '' ? $abs('/') : $abs('/' . $rel);
      $lastmod = gmdate('c', filemtime($file) ?: time());
      $entries[] = ['loc' => $loc, 'lastmod' => $lastmod];
    }
  }

  // ---- Collections (items; optional list indexes) ----
  foreach (array_keys(config()['collections'] ?? []) as $c) {
    if ($includeCollectionIndexes) {
      $entries[] = ['loc' => $abs('/' . $c), 'lastmod' => null];
    }

    $items = list_collection($c) ?? [];
    foreach ($items as $it) {
      $m = $it['meta'] ?? [];
      if (!empty($m['draft']))
        continue;
      if (array_key_exists('sitemap', $m) && $m['sitemap'] === false)
        continue;

      $file = path('collections') . "/$c/{$it['slug']}.md";
      $loc = $abs("/$c/{$it['slug']}");
      $lastmod = is_file($file) ? gmdate('c', filemtime($file)) : null;

      $entries[] = ['loc' => $loc, 'lastmod' => $lastmod];
    }
  }

  // De-dupe & sort
  $byLoc = [];
  foreach ($entries as $e)
    $byLoc[$e['loc']] = $e;
  $entries = array_values($byLoc);
  usort($entries, fn($a, $b) => strcmp($a['loc'], $b['loc']));

  // Build XML
  $xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
  $xml .= "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
  foreach ($entries as $e) {
    $xml .= "  <url>\n";
    $xml .= "    <loc>{$xmlEsc($e['loc'])}</loc>\n";
    if (!empty($e['lastmod'])) {
      $xml .= "    <lastmod>{$xmlEsc($e['lastmod'])}</lastmod>\n";
    }
    $xml .= "  </url>\n";
  }
  $xml .= "</urlset>\n";

  // Write to dist/sitemap.xml
  $target = rtrim($outDir, '/\\') . '/sitemap.xml';
  if (!is_dir(dirname($target)))
    mkdir(dirname($target), 0775, true);
  file_put_contents($target, $xml);
  fwrite(STDOUT, "✓ sitemap.xml\n");
}

function build_pages(string $outDir)
{
  require_once __DIR__ . '/functions.php';
  $pagesPath = path('pages');
  $base = $pagesPath;

  $rii = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($base, FilesystemIterator::SKIP_DOTS)
  );

  foreach ($rii as $f) {
    if (!$f->isFile())
      continue;
    if (strtolower($f->getFilename()) !== 'index.md')
      continue;

    $rel = trim(str_replace($base, '', $f->getPath()), '/\\');
    $urlPath = '/' . $rel;

    $raw = read_file($f->getPathname()) ?? '';
    [$fm, $md] = parse_front_matter($raw);
    $html = markdown_to_html($md);

    $title = $fm['title'] ?? ($rel === '' ? 'Home' : ucwords(str_replace(['-', '_', '/'], ' ', $rel)));
    $meta = $fm;
    $content = $html;
    $template = !empty($meta['template']) ? $meta['template'] : 'main';

    // ✅ Add hero_html
    $hero_html = function_exists('build_hero_html') ? build_hero_html($meta) : '';

    $out = render_to_string(function () use ($template, $title, $content, $meta, $hero_html) {
      $path = $_SERVER['REQUEST_URI'] ?? '/';
      render($template, compact('title', 'content', 'path', 'meta', 'hero_html'));
    });

    $out = fix_relative_assets($out);
    write_html_pretty($outDir, $urlPath === '//' ? '/' : $urlPath, $out);
  }
}

function build_collection_items(string $outDir, string $collection)
{
  require_once __DIR__ . '/functions.php';
  $root = rtrim(path('collections'), '/');
  $dir = $root . '/' . $collection;
  if (!is_dir($dir))
    return;

  foreach (glob($dir . '/*.md') as $mdFile) {
    $slug = basename($mdFile, '.md');
    $item = load_collection_item($collection, $slug);
    if (!$item)
      continue;

    $title = $item['meta']['title'] ?? $slug;
    $meta = $item['meta'] ?? [];
    $content = $item['html'];
    $template = !empty($meta['template']) ? $meta['template'] : 'main';
    $urlPath = url("/{$collection}/{$slug}");

    // ✅ Add hero_html
    $hero_html = function_exists('build_hero_html') ? build_hero_html($meta) : '';

    $out = render_to_string(function () use ($template, $title, $content, $meta, $hero_html) {
      $path = $_SERVER['REQUEST_URI'] ?? '/';
      render($template, compact('title', 'content', 'path', 'meta', 'hero_html'));
    });

    $out = fix_relative_assets($out);
    write_html_pretty($outDir, $urlPath, $out);
  }
}

function build_collection_list(string $outDir, string $collection)
{
  require_once __DIR__ . '/functions.php';

  // Mirror /routes/collections.php logic
  $all = list_collection($collection) ?? [];
  $cfg = config();
  $perPage = $cfg['collections'][$collection]['per_page'] ?? 9;

  $total = count($all);
  $pages = max(1, (int) ceil($total / $perPage));

  // Helper to build pretty URLs for static output
  $hrefFor = function (int $p) use ($collection): string {
    return $p <= 1 ? '/' . $collection : '/' . $collection . '/page/' . $p;
  };

  for ($page = 1; $page <= $pages; $page++) {
    $offset = ($page - 1) * $perPage;
    $itemsPage = array_slice($all, $offset, $perPage);

    // ---- Build inner content only (no header/footer here)
    $contentInner = render_to_string(function () use ($collection, $itemsPage, $page, $pages, $hrefFor) {
      echo '<h1>' . htmlspecialchars(ucfirst($collection), ENT_QUOTES, 'UTF-8') . '</h1>';

      if (!$itemsPage) {
        echo '<p>No items yet.</p>';
        return;
      }

      // cards grid
      $items = $itemsPage;
      include path('partials') . '/cards-grid.php';

      // simple pager (static links)
      echo '<nav class="pager" style="display:flex;gap:.5rem;align-items:center;justify-content:center;margin-block-start:var(--size-2)">';
      if ($page > 1) {
        echo '<a class="button" href="' . htmlspecialchars($hrefFor($page - 1), ENT_QUOTES, 'UTF-8') . '">← Prev</a>';
      } else {
        echo '<span class="button" aria-disabled="true" style="opacity:.5;pointer-events:none">← Prev</span>';
      }

      echo '<span class="muted" style="padding:.25rem .5rem">Page ' . $page . ' of ' . $pages . '</span>';

      if ($page < $pages) {
        echo '<a class="button" href="' . htmlspecialchars($hrefFor($page + 1), ENT_QUOTES, 'UTF-8') . '">Next →</a>';
      } else {
        echo '<span class="button" aria-disabled="true" style="opacity:.5;pointer-events:none">Next →</span>';
      }
      echo '</nav>';
    });

    // ---- Wrap inner content with your site template ONCE
    $title = ucfirst($collection);
    $meta = ['pagination' => ['page' => $page, 'pages' => $pages]];
    $template = 'collection';

    $out = render_to_string(function () use ($template, $title, $contentInner, $meta) {
      $path = $_SERVER['REQUEST_URI'] ?? '/';
      // pass the plain inner HTML as `content`
      render($template, [
        'title' => $title,
        'content' => $contentInner,
        'path' => $path,
        'meta' => $meta,
      ]);
    });

    // Fix asset paths for SSG output
    $out = fix_relative_assets($out);

    // Page 1 → /{collection}/index.html
    // Others → /{collection}/page/{n}/index.html
    $urlPath = $hrefFor($page);
    write_html_pretty($outDir, $urlPath, $out);
  }
}
// --- SSG: tags ---
function build_tags(string $outDir)
{
  require_once __DIR__ . '/functions.php';

  // --- helpers (same logic as the SSR route) ---
  $normalizeTags = function ($raw): array {
    if (is_string($raw)) {
      $arr = array_map('trim', explode(',', $raw));
    } elseif (is_array($raw)) {
      $arr = array_map(fn($t) => is_string($t) ? trim($t) : '', $raw);
    } else {
      $arr = [];
    }
    $unique = [];
    foreach ($arr as $t) {
      if ($t === '')
        continue;
      $key = mb_strtolower($t);
      // keep the first-seen casing for display
      $unique[$key] = $unique[$key] ?? $t;
    }
    return array_values($unique);
  };

  $addFromFile = function (string $file, array &$tags) use ($normalizeTags) {
    $raw = @file_get_contents($file);
    if ($raw === false)
      return;
    [$fm] = parse_front_matter($raw);
    $list = $normalizeTags($fm['tags'] ?? []);
    foreach ($list as $t) {
      $key = mb_strtolower($t);
      $tags[$key]['label'] = $tags[$key]['label'] ?? $t;
      $tags[$key]['count'] = ($tags[$key]['count'] ?? 0) + 1;
    }
  };

  // --- collect tags from content ---
  $tags = [];

  // Collections: content/collections/*/*.md
  $collRoot = rtrim(path('collections'), '/');
  if (is_dir($collRoot)) {
    foreach (glob($collRoot . '/*', GLOB_ONLYDIR) as $dir) {
      foreach (glob($dir . '/*.md') as $md) {
        $addFromFile($md, $tags);
      }
    }
  }

  // Pages: content/pages/*.md  (same scope as your SSR route)
  $pagesDir = rtrim(path('pages'), '/');
  if (is_dir($pagesDir)) {
    foreach (glob($pagesDir . '/*.md') as $md) {
      $addFromFile($md, $tags);
    }
  }

  // Sort natural, case-insensitive by display label
  uasort($tags, fn($a, $b) => strnatcasecmp($a['label'], $b['label']));

  // --- render the same markup as the route ---
  $contentInner = render_to_string(function () use ($tags) {
    ob_start(); ?>
          <h1>Tags</h1>
          <ul class="tags-list">
            <?php if (empty($tags)): ?>
                <li><em>No tags found.</em></li>
            <?php else: ?>
                <?php foreach ($tags as $slug => $info): ?>
                    <li>
                      <a href="<?= url('/tag/' . urlencode($slug)) ?>">
                        <?= htmlspecialchars($info['label'], ENT_QUOTES, 'UTF-8') ?>
                      </a>
                      <small class="muted">(<?= (int) ($info['count'] ?? 0) ?>)</small>
                    </li>
                <?php endforeach; ?>
            <?php endif; ?>
          </ul>
        <?php
        echo ob_get_clean();
  });

  // Pump through your normal template renderer
  $title = 'Tags';
  $meta = [];
  $template = 'main';

  $out = render_to_string(function () use ($template, $title, $contentInner, $meta) {
    $path = '/tags';
    render($template, compact('title', 'path', 'meta') + ['content' => $contentInner]);
  });

  if (function_exists('fix_relative_assets')) {
    $out = fix_relative_assets($out);
  }

  write_html_pretty($outDir, '/tags', $out);
}

// --- SSG: tag ---
function build_tag_pages(string $outDir)
{
  require_once __DIR__ . '/functions.php';

  // --- helpers (mirrors your SSR route) ---
  $getTags = function (array $fm): array {
    $candidates = [];
    foreach ($fm as $key => $val) {
      $lk = strtolower((string) $key);
      if ($lk === 'tags' || $lk === 'tag' || $lk === 'keywords') {
        $candidates[] = $val;
      }
    }
    if (!$candidates)
      return [];

    $collected = [];
    foreach ($candidates as $raw) {
      if (is_string($raw)) {
        foreach (array_map('trim', explode(',', $raw)) as $p) {
          if ($p !== '')
            $collected[] = $p;
        }
      } elseif (is_array($raw)) {
        foreach ($raw as $p) {
          if (is_string($p)) {
            $p = trim($p);
            if ($p !== '')
              $collected[] = $p;
          }
        }
      }
    }
    // de-dupe case-insensitively, keep first-seen casing
    $seen = [];
    foreach ($collected as $t)
      $seen[strtolower($t)] = $t;
    return array_values($seen);
  };

  $slugToTitle = fn($s) => ucwords(str_replace(['-', '_'], ' ', $s));

  // tag_slug => [
  //   'label' => 'PHP',
  //   'items' => [ ['url'=>..., 'title'=>..., 'date'=>..., 'ts'=>...], ... ]
  // ]
  $tagsIndex = [];

  $pushItem = function (string $tSlug, string $tLabel, array $row) use (&$tagsIndex) {
    if (!isset($tagsIndex[$tSlug])) {
      $tagsIndex[$tSlug] = ['label' => $tLabel, 'items' => []];
    }
    $tagsIndex[$tSlug]['items'][] = $row;
  };

  // --- scan collections: content/collections/*/*.md ---
  $collRoot = rtrim(path('collections'), '/');
  if (is_dir($collRoot)) {
    foreach (glob($collRoot . '/*', GLOB_ONLYDIR) as $dir) {
      $collection = basename($dir);
      foreach (glob($dir . '/*.md') as $md) {
        $raw = @file_get_contents($md);
        if ($raw === false)
          continue;
        [$fm] = parse_front_matter($raw);
        $tags = $getTags($fm);
        if (!$tags)
          continue;

        $slug = basename($md, '.md');
        $url = url('/' . $collection . '/' . $slug);
        $title = $fm['title'] ?? $slugToTitle($slug);
        $date = $fm['date'] ?? null;
        $ts = $date instanceof DateTime ? $date->getTimestamp()
          : ($date ? @strtotime((string) $date) : 0);

        foreach ($tags as $t) {
          $tSlug = strtolower($t);
          $pushItem($tSlug, $t, ['url' => $url, 'title' => $title, 'date' => $date, 'ts' => $ts]);
        }
      }
    }
  }

  // --- scan top-level pages: content/pages/*.md (same scope as SSR route) ---
  $pagesDir = rtrim(path('pages'), '/');
  if (is_dir($pagesDir)) {
    foreach (glob($pagesDir . '/*.md') as $md) {
      $raw = @file_get_contents($md);
      if ($raw === false)
        continue;
      [$fm] = parse_front_matter($raw);
      $tags = $getTags($fm);
      if (!$tags)
        continue;

      $slug = basename($md, '.md'); // "index" -> homepage
      $url = url('/' . ($slug === 'index' ? '' : $slug));
      $title = $fm['title'] ?? $slugToTitle($slug);
      $date = $fm['date'] ?? null;
      $ts = $date instanceof DateTime ? $date->getTimestamp()
        : ($date ? @strtotime((string) $date) : 0);

      foreach ($tags as $t) {
        $tSlug = strtolower($t);
        $pushItem($tSlug, $t, ['url' => $url, 'title' => $title, 'date' => $date, 'ts' => $ts]);
      }
    }
  }

  // --- write one page per tag: /tag/{slug}/index.html ---
  foreach ($tagsIndex as $tSlug => $info) {
    $label = $info['label'];
    $rows = $info['items'] ?? [];
    // newest first
    usort($rows, fn($a, $b) => ($b['ts'] ?? 0) <=> ($a['ts'] ?? 0));

    $contentInner = render_to_string(function () use ($tSlug, $rows) {
      ob_start(); ?>
              <h1>Tagged: <?= htmlspecialchars($tSlug, ENT_QUOTES, 'UTF-8') ?></h1>

              <?php if (empty($rows)): ?>
                  <p>No items with this tag yet.</p>
              <?php else: ?>
                  <ul class="item-list flow-0-5" style="margin-block-start: var(--size-3)">
                    <?php foreach ($rows as $row): ?>
                        <li class="item-list-row">
                          <a class="item-list-link" href="<?= htmlspecialchars($row['url'], ENT_QUOTES, 'UTF-8') ?>">
                            <?= htmlspecialchars($row['title'], ENT_QUOTES, 'UTF-8') ?>
                          </a>
                          <?php
                          $d = $row['date'] ?? null;
                          $dateStr = $d instanceof DateTime ? $d->format('Y-m-d') : (is_string($d) ? $d : '');
                          ?>
                          <?php if ($dateStr): ?>
                              <small class="item-list-date muted"><?= htmlspecialchars($dateStr, ENT_QUOTES, 'UTF-8') ?></small>
                          <?php endif; ?>
                        </li>
                    <?php endforeach; ?>
                  </ul>
              <?php endif; ?>
            <?php
            echo ob_get_clean();
    });

    $title = 'Tagged: ' . $label;
    $meta = []; // you could add meta description if desired
    $template = 'main';

    $out = render_to_string(function () use ($template, $title, $contentInner, $meta) {
      $path = $_SERVER['REQUEST_URI'] ?? '/';
      render($template, compact('title', 'meta') + ['content' => $contentInner, 'path' => $path]);
    });

    if (function_exists('fix_relative_assets')) {
      $out = fix_relative_assets($out);
    }

    write_html_pretty($outDir, '/tag/' . urlencode($tSlug), $out);
  }
}

// --- SSG: search ---
function build_search_shell(string $outDir)
{
  require_once __DIR__ . '/functions.php';

  // Same markup skeleton that SSR route uses (form + containers)
  $shell = <<<HTML
<div class="flow">
  <h1>Search</h1>

  <search>
    <form id="site-search" method="get" action="/search" class="search-form flex flex-wrap gap-0-2-5" style="margin-block:1rem;" role="search">
      <label for="q" class="visually-hidden">Search query</label>
      <input id="q" type="search" name="q" placeholder="Search pages and collections…" style="padding:.5rem .75rem; width:min(40rem,100%);" aria-label="Search query">
      <button type="submit" class="btn" style="margin-block-start:0; padding:.5rem .75rem;">Search</button>
      <select id="in" name="in" style="padding:.5rem .75rem;" aria-label="Scope">
        <option value="all" selected>All</option>
        <option value="pages">Pages</option>
        <option value="items">Collections</option>
      </select>
    </form>
  </search>

  <noscript><p><em>Search results require JavaScript.</em></p></noscript>

  <p id="search-status" class="muted" aria-live="polite" style="margin-block:.5rem 1rem;"></p>
  <ul id="search-results" class="item-list flow-0-5" style="margin-block-start: var(--size-3)"></ul>

  <script type="module" src="/static/js/search.js"></script>
</div>
HTML;

  $title = 'Search';
  $meta = ['description' => 'Search pages and collections'];
  $template = 'main';

  $out = render_to_string(function () use ($template, $title, $shell, $meta) {
    $path = '/search';
    render($template, ['title' => $title, 'content' => $shell, 'path' => $path, 'meta' => $meta]);
  });

  $out = fix_relative_assets($out);
  write_html_pretty($outDir, '/search', $out);
}

function build_search_index(string $outDir)
{
  require_once __DIR__ . '/functions.php';

  $items = [];

  // PAGES
  $pagesDir = rtrim(path('pages'), '/');
  if (is_dir($pagesDir)) {
    $it = new RecursiveIteratorIterator(
      new RecursiveDirectoryIterator($pagesDir, FilesystemIterator::SKIP_DOTS)
    );
    foreach ($it as $f) {
      if (!$f->isFile() || strtolower($f->getExtension()) !== 'md')
        continue;
      $abs = $f->getPathname();
      $rel = trim(str_replace($pagesDir, '', $abs), '/');
      $rel = preg_replace('/\.md$/i', '', $rel);

      // URL rules: index → '/', foo/index → '/foo', else '/{rel}'
      if ($rel === 'index')
        $url = '/';
      elseif (substr($rel, -6) === '/index')
        $url = '/' . substr($rel, 0, -6);
      else
        $url = '/' . $rel;

      [$fm, $md] = parse_front_matter(read_file($abs) ?? '');
      if (!empty($fm['draft']))
        continue;

      $html = markdown_to_html($md);
      $text = trim(preg_replace('/\s+/', ' ', strip_tags($html)));

      $title = (string) ($fm['title'] ?? basename($rel));
      $desc = (string) ($fm['description'] ?? '');
      $date = $fm['date'] ?? null;
      $dateS = $date instanceof DateTime ? $date->format('Y-m-d') : (is_string($date) ? $date : null);

      $items[] = [
        'type' => 'page',
        'url' => $url,
        'title' => $title,
        'desc' => $desc,
        'text' => $text,
        'date' => $dateS,
      ];
    }
  }

  // COLLECTION ITEMS
  foreach (array_keys(config()['collections'] ?? []) as $c) {
    foreach (list_collection($c) as $it) {
      $slug = $it['slug'];
      $file = path('collections') . "/$c/$slug.md";

      [$fm, $md] = parse_front_matter(read_file($file) ?? '');
      if (!empty($fm['draft']))
        continue;

      $html = markdown_to_html($md);
      $text = trim(preg_replace('/\s+/', ' ', strip_tags($html)));

      $title = (string) ($fm['title'] ?? ucwords(str_replace(['-', '_'], ' ', $slug)));
      $desc = (string) ($fm['description'] ?? '');
      $date = $fm['date'] ?? null;
      $dateS = $date instanceof DateTime ? $date->format('Y-m-d') : (is_string($date) ? $date : null);

      $items[] = [
        'type' => $c,
        'url' => "/$c/$slug",
        'title' => $title,
        'desc' => $desc,
        'text' => $text,
        'date' => $dateS,
      ];
    }
  }

  // Write JSON
  $destDir = rtrim($outDir, '/\\') . '/static/data';
  if (!is_dir($destDir))
    mkdir($destDir, 0775, true);
  $json = json_encode(['items' => $items], JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
  file_put_contents($destDir . '/search-index.json', $json);
  fwrite(STDOUT, "✓ built /static/data/search-index.json (" . strlen($json) . " bytes)\n");
}

// --- SSG: robots.txt ---
function build_robots_txt(string $outDir)
{
  // Prefer absolute base_url from config; otherwise allow an env override.
  // Fallback to http://localhost:8000 as a last resort (avoids a blank/relative URL).
  $cfg = config();
  $baseUrl = (string) ($cfg['site']['base_url'] ?? '');
  if (!preg_match('~^https?://~i', $baseUrl)) {
    $env = getenv('NOSTY_BASE_URL') ?: getenv('SITE_ORIGIN') ?: '';
    $baseUrl = $env && preg_match('~^https?://~i', $env) ? $env : 'http://localhost:8000';
  }
  $absBase = rtrim($baseUrl, '/');

  $lines = [
    'User-agent: *',
    'Disallow: /*.md$',
    // Uncomment the next line if you don’t want crawlers to index asset files:
    // 'Disallow: /static/',
    '',
    "Sitemap: {$absBase}/sitemap.xml",
    '',
  ];
  $out = rtrim($outDir, "/\\") . '/robots.txt';
  if (!is_dir(dirname($out))) {
    mkdir(dirname($out), 0775, true);
  }
  if (file_put_contents($out, implode("\n", $lines)) === false) {
    fwrite(STDERR, "Failed to write robots.txt → $out\n");
    exit(1);
  }
  fwrite(STDOUT, "✓ wrote robots.txt → $out\n");
}

// ---------- Command: build ----------
if ($cmd === 'build') {
  // Options: --out=dist --clean --robots=allow|disallow --base=https://site.example
  $outDir = 'dist';
  $clean = false;
  $robotsPolicy = 'allow'; // default
  $cliBase = null;

  foreach (array_slice($argv, 1) as $a) {
    if (strpos($a, '--out=') === 0)
      $outDir = substr($a, 6);
    if ($a === '--clean')
      $clean = true;
    if (strpos($a, '--robots=') === 0) {
      $v = strtolower(substr($a, 9));
      if (in_array($v, ['allow', 'disallow'], true))
        $robotsPolicy = $v;
    }
    if (strpos($a, '--base=') === 0) {
      $cliBase = rtrim(substr($a, 7), '/');
    }
  }

  $outDir = rtrim($outDir, '/\\');

  if ($clean && is_dir($outDir)) {
    $it = new RecursiveIteratorIterator(
      new RecursiveDirectoryIterator($outDir, FilesystemIterator::SKIP_DOTS),
      RecursiveIteratorIterator::CHILD_FIRST
    );
    foreach ($it as $f) {
      $f->isDir() ? rmdir($f->getPathname()) : unlink($f->getPathname());
    }
    rmdir($outDir);
  }
  if (!is_dir($outDir))
    mkdir($outDir, 0775, true);

  require_once __DIR__ . '/functions.php';

  // robots policy can be overridden by env (e.g. Netlify UI)
  $envRobots = getenv('NOSTY_ROBOTS');
  if ($envRobots && in_array(strtolower($envRobots), ['allow', 'disallow'], true)) {
    $robotsPolicy = strtolower($envRobots);
  }

  // Compute absolute base for sitemap/robots
  // Priority: --base => NOSTY_BASE_URL => Netlify URL => config.site.base_url (if absolute)
  $absBase = null;

  if ($cliBase) {
    $absBase = $cliBase;
  } elseif ($v = getenv('NOSTY_BASE_URL')) {
    $absBase = rtrim($v, '/');
  } elseif ($v = getenv('URL')) { // Netlify
    $absBase = rtrim($v, '/');
  } else {
    $cfgBase = trim((string) (config()['site']['base_url'] ?? ''), '/');
    if (preg_match('~^https?://~i', (string) (config()['site']['base_url'] ?? ''))) {
      $absBase = rtrim((string) config()['site']['base_url'], '/');
    }
  }
  // If still not absolute, leave $absBase as null → we'll skip the sitemap line in robots.

  // Write robots.txt (single call; remove any older build_robots_txt call)
  write_static_robots($outDir, $robotsPolicy, $absBase);
  fwrite(STDOUT, "✓ robots.txt ({$robotsPolicy})\n");

  // 1) copy static assets
  $staticSrc = __DIR__ . '/static';
  $staticDst = $outDir . '/static';
  copy_dir_recursive($staticSrc, $staticDst);
  fwrite(STDOUT, "✓ copied /static → $staticDst\n");

  // 2) render pages
  build_pages($outDir);

  // 3) render collections (lists + items)
  $cfg = config();
  foreach (array_keys($cfg['collections'] ?? []) as $collection) {
    build_collection_list($outDir, $collection);
    build_collection_items($outDir, $collection);
  }

  // 4) search shell + index
  build_search_shell($outDir);
  build_search_index($outDir);

  // 5) tags
  build_tags($outDir);
  build_tag_pages($outDir);

  // 6) sitemap (pass $absBase if your function accepts it; otherwise ensure it computes the same way)
  build_sitemap($outDir, /* include collection indexes? */ false);

  fwrite(STDOUT, "Build complete → $outDir\n");
  exit(0);
}

// ---------- fallback ----------
fwrite(STDERR, "Unknown command: $cmd\n\n");
exit_help(1);
