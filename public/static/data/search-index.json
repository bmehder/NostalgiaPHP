{"items":[{"type":"page","url":"/contact","title":"Contact","desc":"This is an example of a simple Contact page template with a fake contact form in NostalgiaPHP.","text":"","date":null},{"type":"page","url":"/about/blink","title":"Blink Reactivity","desc":"Blink is a dead-simple reactive signal system for JavaScript ‚Äî no tooling, no build steps, no opinions.","text":"Blink Reactivity Blink is a dead-simple reactive signal system for JavaScript ‚Äî no tooling, no build steps, no opinions. Blink gives you three primitives: explicit() ‚Äì to create state that is manually updated implicit() ‚Äì to create state derived from explicit state fx() ‚Äì to create side effects that re-run when state changes Learn more at NPM. Mental Model for Any Reactive UI Library (React, Vue, Svelte, Blink, etc.): library eats state ‚Üí view comes out library(üì¶) ‚Üí üí©üëÄ The view is always the result of applying the library to the state ‚Äî in real time. Change the state ‚Üí the view reacts to the change. (state ‚Üí library ‚Üí view) .accordion [data-panel] { padding-block: var(--size-0-5); padding-inline: var(--size); } Demos Accordion-ish Thing Uses explicit state isOpen. First instance. Independent state. Second instance. Independent state. Third instance. Independent state. Counter Uses explicit state count and implicit state doubled. - + Reset Count: Doubled:","date":"2025-09-06"},{"type":"page","url":"/about/slider","title":"Slider","desc":"","text":"","date":"2025-10-07"},{"type":"page","url":"/about/blank","title":"Blank","desc":"This is an example of a blank page template in NostalgiaPHP.","text":"Nested page This page is nested.","date":null},{"type":"page","url":"/about/fetch","title":"Fetch Example","desc":"This fetch example uses a client side app to fetch and display from a REST API.","text":"Fetching and rendering dynamic data While NostalgiaPHP keeps things simple with flat files, you can still add client-side behavior where you need it. This example fetches todos from the JSONPlaceholder API and displays them in a list. Each item can be marked complete or incomplete in the browser. No server-side code required. State is managed with Blink, a tiny reactive utility that tracks changes and re-renders only what‚Äôs needed. The result is a snappy, modern feel without pulling in a heavyweight framework. It‚Äôs the same idea as the gallery example: small, portable code that you can drop into any NostalgiaPHP project. You can even persist state to local or session storage if you want it to stick between visits. Note: State not persisted in this example. All Active Completed","date":"2025-09-13"},{"type":"page","url":"/about/components","title":"Browser Components","desc":"Demo of some css-only versions of UI elements that used to require JavaScript.","text":"main .content { display: grid; } CSS-only* Browser Components UI components that once seemed to require JavaScript‚Äîoften built with frameworks like React‚Äîare now possible with nothing more than HTML and CSS. The web platform has grown dramatically, with modern CSS introducing features like scroll snapping, the &lt;details&gt; element, and the native &lt;dialog&gt; API. These tools let us build interactive patterns that used to demand JavaScript, while keeping our code lighter and easier to maintain. This isn‚Äôt about replacing JavaScript entirely, but about recognizing where the platform already gives us what we need. Every time we lean on native HTML and CSS instead of shipping extra JS, we get better performance, simpler code, and improved accessibility for free. Carousel This carousel looks and feels like something you‚Äôd normally reach for JavaScript to build, but it‚Äôs powered entirely by modern CSS. Scrolling &amp; snapping ‚Äî The cards sit in a horizontal strip you can swipe or scroll through. CSS scroll snapping keeps each card neatly centered as you stop. Navigation buttons ‚Äî Instead of custom JavaScript, the browser provides built-in scroll buttons you can style directly with CSS. They appear at the edges and let you step through smoothly. Indicators (dots) ‚Äî Markers show where you are in the carousel, also handled through CSS pseudo-elements. No extra markup or scripting needed. Responsive by default ‚Äî Because it‚Äôs flexbox + aspect ratio, the layout adapts gracefully to small or large screens. In short: the browser‚Äôs layout and scrolling engine is doing all the work. We‚Äôre just layering on styles. Note: If your browser doesn‚Äôt support newer CSS features like ::scroll-button and ::scroll-marker, you may not see the carousel controls or indicators. That‚Äôs okay ‚Äî the content is still fully accessible as a scrollable strip. This is an example of progressive enhancement, where modern browsers get the upgraded experience, while older ones still get a usable fallback. Accordion This accordion is JS-free, built with native &lt;details&gt; and a shared name to ensure only one section is open at a time. Semantic HTML: &lt;details&gt; / &lt;summary&gt; communicates ‚Äúdisclosure‚Äù to browsers, screen readers, and keyboards. Built-in UX: Space/Enter toggles; the tab key moves focus between summaries (browser-dependent). Mutual exclusivity: Giving all &lt;details&gt; the same name attribute turns them into a group‚Äîopening one closes the others. What is NostalgiaPHP? A tiny flat-file CMS: Markdown in, HTML out‚Äîno DB, no build step. How do I add a page? Create content/pages/your-page/index.md with front-matter and content. How do collections work? Put items in content/collections/{name} as .md files (one per item). Can I use templates and partials? Yes‚Äîpick template: main (or your own), and reuse partials like header/footer. Where can I deploy? Anywhere PHP runs‚Äîshared hosting, Render, Netlify PHP adapters, etc. Tabs Tabs let you organize related content into panels where only one is visible at a time. Traditionally, this required JavaScript to toggle states and hide/show panels. But with plain HTML and CSS, we can achieve the same behavior using radio inputs and labels. Each tab is backed by a hidden radio input (so only one can be active at a time), and the labels act as the clickable tab headers. CSS then uses the :checked state to display the correct panel. This approach is accessible by default (since radios are part of the native form controls), keyboard-friendly, and requires no scripting. It‚Äôs also easy to style so the tabs look like the traditional UI pattern users expect. Overview Features Pricing Overview This is the overview panel. Features This is the features panel. Pricing This is the pricing panel. CSS Dialogs I am a modal Lorem ipsum dolor, sit amet consectetur adipisicing elit. Repellat nulla ad nemo. Close The &lt;dialog&gt; element gives you a built-in way to create modals without JavaScript. Opening and closing is handled natively with .showModal() and .close() (so, a little JS, but let's move on), and the browser automatically adds a dimmed backdrop behind the dialog. This means you don‚Äôt need to wire up ARIA attributes, focus trapping, or overlay click handling yourself ‚Äî it‚Äôs all provided by the platform. You can still style the dialog and its backdrop to fit your design. Note: Backdrop styling (via ::backdrop) is still inconsistent across browsers. Some support blur and custom colors, while others are limited. Not progressively enhanced. Show Modal Before/After Comparison Another classic UI pattern that used to almost always rely on heavy JavaScript libraries is the before‚Äìafter slider. In this version, CSS handles the actual reveal effect using clip-path and a custom property. JavaScript plays only a minimal role: wiring up the range input so its value updates the CSS variable. So, it is not progressively enhanced. It‚Äôs a much lighter approach than older libraries ‚Äî most of the work is done natively in CSS, while JS just provides the bridge between user input and styling.","date":null},{"type":"page","url":"/about","title":"About","desc":"NostalgiaPHP gives you the essentials ‚Äî nothing more, nothing less ‚Äî so you can just build.","text":"pre { max-width: 100% !important; } Why another CMS? Because modern web development doesn‚Äôt have to be chaos. NostalgiaPHP gives you the essentials ‚Äî nothing more, nothing less ‚Äî so you can just build. For example, here‚Äôs a simple client-side image gallery with a lightbox. The JavaScript is completely standalone, and the CSS lives in its own file. Together they‚Äôre easy to reuse, drop into other projects, and move between sites with zero external dependencies. Client-side rendered gallery Gallery Code &lt;script type=\"module\" src=\"/static/js/apps/gallery.js\"&gt;&lt;/script&gt; &lt;div class=\"auto-fill\" data-gallery=\" /static/media/1.jpg, /static/media/2.jpg, /static/media/3.jpg, /static/media/4.jpg, /static/media/5.jpg, /static/media/6.jpg \" &gt;&lt;/div&gt;","date":null},{"type":"page","url":"/","title":"Welcome to NostalgiaPHP","desc":"Build content sites fast with flat files. No framework. No database. Just pages, collections, and a few partials.","text":"","date":null},{"type":"blog","url":"/blog/not-nostalgia-php","title":"You Might Not Want to Use NostalgiaPHP","desc":"A critical look at NostalgiaPHP, weighing its promise of simplicity against the complexities of modern web development.","text":"You Might Not Want to Use NostalgiaPHP Every few years the web development world rediscovers a seductive idea: what if we could just keep things simple? Write Markdown files, sprinkle in some templates, glue it together with a few hundred lines of PHP, and voil√† ‚Äî a CMS without the CMS. NostalgiaPHP is the latest to embody this dream, and the appeal is understandable. Many developers have spent years building tools like SvelteKit, Next.js, and others to combat complexity, so there is sympathy for this approach. But it‚Äôs worth interrogating the ‚Äúreturn to simplicity‚Äù narrative before canonizing it as the future. The false binary There‚Äôs a tendency to frame modern frameworks as bloated monstrosities, weighed down by build tools, hydration, reactive state libraries, and endless npm dependencies. And then, by contrast, something like NostalgiaPHP seems almost heroic: no build step, no database, just files on disk and some elegant PHP helpers. But the choice is not binary. Complexity doesn‚Äôt accrue because developers are masochists; it accrues because requirements do. Accessibility, security, offline support, progressive enhancement, internationalization, streaming, SSR, hydration, edge deployment, scalability ‚Äî these are not optional for many teams. Pretending otherwise risks setting people up for a painful awakening when ‚Äúthe simple thing‚Äù no longer meets their needs. The persistence of state NostalgiaPHP is primarily a server-side rendering (SSR) framework, with static site generation (SSG) offered as a side option. Static site generation is powerful. It reduces runtime complexity and infrastructure cost. But real-world apps aren‚Äôt just documents; they‚Äôre conversations between user and server, perpetually changing. Forms, authentication, dashboards, collaborative editing, live data streams ‚Äî these are not accidental. They‚Äôre what the web is. A framework that only concerns itself with ‚Äúcontent in, HTML out‚Äù risks relegating itself to brochureware. That‚Äôs not a criticism if brochureware is all you need. But calling it a general solution to the web is misleading. Reinventing the wheel, again One of the ironies of NostalgiaPHP is that it touts its lack of frameworks as a virtue ‚Äî and then slowly re-implements framework features by hand: routing, tags, search indexes, breadcrumbs, page animations. At some point, you‚Äôve built‚Ä¶ a framework. The problem is, unlike established frameworks, you don‚Äôt benefit from the ecosystem‚Äôs accumulated wisdom: performance profiling, accessibility audits, cross-browser quirks, security research, battle-tested plugins. You‚Äôre on your own. That‚Äôs a heavy price for nostalgia. The real lesson This is not to sound dismissive. Experiments like this remind us that complexity isn‚Äôt inevitable, and that it‚Äôs possible to ship real sites with almost nothing. But caution is warranted against romanticizing it into a movement. The future of the web is not about rejecting frameworks or databases or build tools. It‚Äôs about making them disappear into the background, giving developers the illusion of simplicity without sacrificing power. That‚Äôs the direction many modern tools are moving towards ‚Äî zero-config builds, compile-time reactivity, tiny runtime footprints. NostalgiaPHP is a nice reminder that HTML is still HTML, CSS is still CSS, and Markdown is a joy. But the future won‚Äôt come from rewinding the tape. It‚Äôll come from reimagining what developer experience can be in the face of real-world complexity.","date":"2025-10-08"},{"type":"blog","url":"/blog/appear-animations","title":"Appear Animations","desc":"A lightweight, JS-assisted approach to scroll-based reveal animations using IntersectionObserver and CSS transitions.","text":"Appear Animations Subtle scroll-based animations can make a page feel alive without pulling in a large library like GSAP. We can build a lightweight ‚Äúappear‚Äù helper by combining: IntersectionObserver ‚Üí detect when elements enter the viewport. CSS transitions ‚Üí handle the actual fade/slide/scale animations. A simple .is-visible toggle ‚Üí applied once, no reflows. This balances performance and user experience while respecting prefers-reduced-motion. CSS Instead of hardcoding hidden/visible styles globally, we can keep things safe: if the JavaScript never loads, elements remain visible. The script injects the CSS rules dynamically. .appear { --appear-translate: 128px; opacity: 0; transform: translateY(20px); transition: opacity 0.5s ease, transform 0.5s ease; will-change: opacity, transform; /* appeared */ &amp;.is-visible { opacity: 1; transform: none; } } /* Variants override the baseline transform */ .appear-up { transform: translateY(var(--appear-translate)); } .appear-down { transform: translateY(calc(var(--appear-translate) * -1)); } .appear-left { transform: translateX(var(--appear-translate)); } .appear-right { transform: translateX(calc(var(--appear-translate) * -1)); } .appear-scale { transform: scale(0.95); } JavaScript The script observes .appear elements and applies .is-visible when they enter the viewport: // No IO support ‚Üí reveal immediately (again: no hiding CSS injected). const revealAllNow = () =&gt; { const show = () =&gt; { document .querySelectorAll('.appear') .forEach(el =&gt; el.classList.add('is-visible')) } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', show, { once: true }) } else { show() } } // Respect reduced motion ‚Üí don't inject the hiding CSS; just reveal. if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) { revealAllNow() } else if (!('IntersectionObserver' in window)) { // No IO support ‚Üí reveal immediately (again: no hiding CSS injected). revealAllNow() } else { // JS present ‚Üí inject CSS (so elements can start hidden) and observe injectCSS() const onIntersect = entries =&gt; { entries.forEach(entry =&gt; { if (entry.isIntersecting) { entry.target.classList.add('is-visible') io.unobserve(entry.target) } }) } const io = new IntersectionObserver(onIntersect, { threshold: 0.2 }) const start = () =&gt; { const targets = document.querySelectorAll('.appear') if (!targets.length) return targets.forEach(el =&gt; io.observe(el)) } if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', start, { once: true }) } else { start() } } Usage &lt;!-- Include in &lt;head&gt; or template, etc. --&gt; &lt;script defer src=\"/static/js/apps/appear.js\"&gt;&lt;/script&gt; &lt;h2 class=\"appear appear-up\"&gt;Fade In Heading&lt;/h2&gt; &lt;p class=\"appear appear-scale\"&gt;This paragraph scales up slightly as it fades in.&lt;/p&gt; &lt;div class=\"appear appear-left\"&gt;Slide from left&lt;/div&gt; &lt;div class=\"appear appear-right\"&gt;Slide from right&lt;/div&gt; Progressive Enhancement ‚ö†Ô∏è JavaScript is required for this effect. If the script doesn‚Äôt load, .appear elements will remain visible by default. The animations are a progressive enhancement ‚Äî the page works fine without them. ‚ú® That‚Äôs all it takes: a sprinkle of CSS + IntersectionObserver for lightweight appear animations.","date":"2025-10-02"},{"type":"blog","url":"/blog/blink-a-tiny-reactive-layer","title":"Don't Blink!","desc":"Blink is a tiny JavaScript reactivity layer ‚Äî no framework, no bundler, no virtual DOM. Just signals, effects, and simple state management you can copy-paste into any project.","text":"Don't Blink! Blink: A Tiny Reactivity Layer Sometimes you want a little bit of state and reactivity in your project ‚Äî but you don‚Äôt want to bring in a whole framework, a bundler, or a giant runtime. That‚Äôs where Blink comes in. Blink is only a few lines of JavaScript. You can copy-paste it into a file, or install it from npm or a cdn if you like. It gives you three exports: explicit, implicit, and fx. let subscriber = null export const explicit = value =&gt; { const subscriptions = new Set() return { get value() { if (subscriber) { subscriptions.add(subscriber) } return value }, set value(newValue) { value = newValue subscriptions.forEach(fn =&gt; fn()) }, } } export const implicit = fn =&gt; { const _implicit = explicit() fx(() =&gt; { _implicit.value = fn() }) return _implicit } export const fx = fn =&gt; { subscriber = fn fn() subscriber = null } How it works explicit() creates a reactive value. Think of it as a simple signal ‚Äî count = explicit(0) ‚Äî that notifies subscribers when it changes. fx() sets up a reactive effect. When you access a signal inside an fx function, that effect is re-run whenever the signal changes. implicit() is just sugar. It creates a derived signal, automatically re-computing its value whenever its dependencies change. That‚Äôs it. No virtual DOM, no compiler, no JSX. Just getters, setters, and a subscription set. Example Check out some demos: Counter Data Fetching Why Blink? Blink is not trying to be React or Svelte. It‚Äôs not even trying to be a framework. It‚Äôs just a tiny reactivity core that makes otherwise static sites feel alive. That makes it a perfect companion for projects like Nostalgia, where you mostly want flat-file content, but you occasionally need a sprinkle of dynamic behavior without introducing complexity. Further reading Slank on npm (Blink‚Äôs package name)","date":"2025-09-18"},{"type":"blog","url":"/blog/markdown-example","title":"Markdown Example","desc":"An example of using writing markdown.","text":"View the markdown file here. Markdown Example H1 Heading (for page titles) H2 Heading H3 Heading Paragraphs This is a normal paragraph. It can contain bold, italic, and inline code. Lists Unordered item 1 Unordered item 2 Nested item Unordered item 3 Ordered item one Ordered item two Ordered item three Links Go to homepage Images Blockquotes This is a blockquote. It can span multiple lines. Code blocks // Example JavaScript code function hello(name) { return `Hello, ${name}!` } console.log(hello(\"World\")) &lt;?php // Example PHP code echo \"Hello from PHP!\"; &lt;!-- Example HTML --&gt; &lt;div class=\"box\"&gt;Hello World&lt;/div&gt; Tables Column 1 Column 2 Column 3 Row 1 Data A Data B Row 2 Data C Data D Horizontal rule Final notes You can also write html in markdown files, but you can't nest markdown inside of html. This sample page demonstrates the whole kit and kaboodle of Markdown features supported in NostalgiaPHP.","date":"2025-09-17"},{"type":"blog","url":"/blog/markdown-crash-course","title":"Markdown Crash Course","desc":"How to write markdown.","text":"Markdown Crash Course This page was created with Markdown. I just clicked \"Share\" on YouTube and copy/pasta the provided embed code. You can also use HTML in Markdown files. Find a simple Markdown Cheat Sheet online. You will get the hang of it quickly.","date":"2025-09-14"},{"type":"blog","url":"/blog/nostalgia-manifesto","title":"The NostalgiaPHP Manifesto","desc":"The NostalgiaPHP Manifesto is a core set of values to understand the philosphy behing NostalgiaPHP.","text":"The NostalgiaPHP Manifesto Keep it simple. If all you need is to show content and sprinkle in a little JavaScript, this is the easiest way I know to publish a site. Essentials included. You get a sitemap.xml, robots.txt, a 404 page, and control over SEO basics (titles, meta descriptions, and sitemap inclusion). Flexible Markdown. Write plain Markdown, drop in HTML when you need more control, or mix the two inside a file. Extend with templates. If Markdown isn‚Äôt enough, make a PHP template and reuse partials. Low-friction workflow. Develop locally, push to GitHub, and deploy to Render.com (or anywhere with PHP). Minimal dependencies. Anything else introduces setup, maintenance, and fragility. Add features only when you actually need them. Extend outward. Lean on microservices or language1.agnostic tools (like standalone contact forms) instead of inflating the core. Easy exit ramp. If you outgrow this, migrate your styles and content, then rebuild views in another framework or language.","date":"2025-09-12"},{"type":"blog","url":"/blog/nostalgia-php-overview","title":"NostalgiaPHP Overview","desc":"NostalgiaPHP is a lightweight site engine that treats your whole website like a folder.","text":"NostalgiaPHP Overview What is NostalgiaPHP? NostalgiaPHP is a lightweight site engine that treats your whole website like a folder. Portable ‚Üí your entire site is just files; zip it, copy it, push it to GitHub. Zero-setup deploy ‚Üí drop the folder onto a PHP server, and you‚Äôre live. Simple backups ‚Üí copy the directory, done. Version control with GitHub is usually enough. Rapid prototyping ‚Üí spin up an idea, deploy, and test in minutes. Design freedom ‚Üí edit templates, CSS, and partials without a framework fighting you. Future-proof ‚Üí if you move to WordPress, Next, or anything else later, you already have your Markdown, styles, and assets. It‚Äôs for developers who want to ship real content websites fast without committing to a heavyweight CMS or framework.","date":"2025-09-08"},{"type":"blog","url":"/blog/why-nostalgia-php","title":"Why NostalgiaPHP?","desc":"Building a simple website today often comes with a lot of extra baggage. But what if you just need a small site?","text":"Why NostalgiaPHP? The Problem Building a simple website today often comes with a lot of extra baggage: WordPress ‚Üí instantly drags in a DB, admin UI, plugins, themes, update cycles, PHP version nags, etc. Astro / Next / Eleventy ‚Üí modern, fast, static-friendly‚Ä¶ but need Node, npm, dependencies, configs, build steps. Jekyll / Hugo ‚Üí great static site generators, but you need Ruby or Go, and a build process. Server side rendering has many more advantages. They‚Äôre all fantastic at scale. But what if you just need a small site ‚Äî a few pages, a blog or portfolio, and a header and footer? The Solution NostalgiaPHP: Built in plain PHP. Zero database. Zero build step. Zero frameworks. Just Markdown files with front matter ‚Üí served as pages and collections. Drop them in /content/pages or /content/collections/{name}/ and you‚Äôre live. Run one command: php -S localhost:8000 ‚Ä¶and you‚Äôre looking at your site. The Philosophy Pages are Markdown files. Collections are just folders of Markdown files. Partials are PHP includes. Templates are simple PHP files. Assets are whatever you put in /static. No database migrations. No npm install. No build pipeline. No JS metaframeworks.","date":"2025-09-08"},{"type":"blog","url":"/blog/astro-comparison","title":"NostalgiaPHP vs Astro","desc":"A comparison between Astro and NostalgiaPHP. Both are tools for building content-heavy sites.","text":"NostalgiaPHP vs Astro Both are tools for building content-heavy sites. Both lean on files, not databases. But one is caveman simple, and the other is modern meta-framework simple. üêò NostalgiaPHP Markdown or HTML + PHP. That‚Äôs it. File-based routing. Pages and collections map directly to the file system. Zero build step. No npm run build, no node_modules. Instant deploy. Upload the folder, site goes live. Portable. Your project folder is the site. üöÄ Astro Islands architecture. HTML by default, sprinkle JS where needed. File-based routing. Drop .astro files into src/pages. Build step required. Always needs Node, npm, and a build process. Integrations galore. React, Svelte, Vue, Tailwind, Markdown, MDX, etc. Portable (after build). You ship the compiled output, not your source. ‚ú® The Similarity Both say: ‚ÄúThe web is mostly content. Let‚Äôs optimize for content.‚Äù Astro ships pure HTML by default. NostalgiaPHP ships pure HTML too ‚Äî it just skips the compile step. üöÄ The Difference NostalgiaPHP = raw, server-side simplicity. Markdown in, HTML out, no tooling. Astro = modern static-site generator + meta-framework. Flexible, but requires a build and an ecosystem. TL;DR If you want the fastest path from Markdown to website, without any toolchain: üëâ Make site. Files good. Framework bad. (NostalgiaPHP) If you want a modern static generator with integrations and a plugin ecosystem: üëâ Astro.","date":"2025-09-07"},{"type":"blog","url":"/blog/rails-vs-nostalgia","title":"NostalgiaPHP vs Ruby on Rails","desc":"A comparison of Ruby on Rails and NostalgiaPHP. These projects have very different ideas about development.","text":"NostalgiaPHP vs Ruby on Rails Framework heavyweight meets folder of files. Rails in a Nutshell Rails popularized the modern web framework: MVC, migrations, scaffolding, ORM, helpers, asset pipeline, gems, the works. Convention over configuration: you get generators, opinionated folder structures, helpers, and rails-specific idioms. It‚Äôs fantastic if you‚Äôre building a web app with data models, users, authentication, dashboards, and lots of interactions. The tradeoff: complexity. You need Ruby, Bundler, Rails installed. You inherit conventions. You have to learn ‚Äúthe Rails way.‚Äù NostalgiaPHP in a Nutshell Not a framework at all. Just plain PHP + folders. Your ‚Äúdatabase‚Äù is Markdown files. Your ‚Äúviews‚Äù are PHP partials and templates. Your ‚Äúroutes‚Äù are basically index.php with if/else. Deployment = drop the folder on a server that has PHP. Backup = copy the folder. It‚Äôs not trying to be Rails lite. It‚Äôs the opposite philosophy: strip away everything until the files themselves are the source of truth. Key Contrasts Dimension Rails NostalgiaPHP Setup Install Ruby, Rails, Bundler, configure DB Upload folder to server with PHP Content Database tables &amp; ActiveRecord models Markdown files with front-matter Architecture MVC (models, views, controllers) Pages, collections, partials Flexibility Tons of plugins (gems) Roll your own partials/templates Performance Runs Ruby app server (Puma/Passenger) Served directly by Apache/Nginx + PHP Scaling Suited for apps with lots of business logic Suited for content-heavy small sites Learning Learn Rails conventions Know PHP basics, Markdown, HTML, CSS Deployment Capistrano, Heroku, containerization Copy folder to webroot, done Who They‚Äôre For Rails: web application developers who need complexity: user accounts, APIs, dashboards, background jobs, scaling. NostalgiaPHP: people who want to ship a website, not an app. Something closer to ‚Äúdigital documents + light design.‚Äù The Overlap Ironically, both Rails and NostalgiaPHP were born from the same itch: stop reinventing the wheel. Rails said: ‚ÄúWe keep writing the same controllers, migrations, and forms. Let‚Äôs codify them into a framework.‚Äù NostalgiaPHP says: ‚ÄúWe keep writing the same header, footer, and blog loop. Let‚Äôs boil it down to a folder of Markdown and a few PHP files.‚Äù üëâ So if Rails is a Swiss Army knife with every attachment, NostalgiaPHP is a pocketknife ‚Äî sharp, portable, good enough for most jobs, but not pretending to be a power tool.","date":"2025-09-07"},{"type":"blog","url":"/blog/sveltekit-comparison","title":"NostalgiaPHP vs SvelteKit","desc":"A comparison between SvelteKit and NostalgiaPHP‚Äìtwo very different tools with the same nostalgic goal.","text":"NostalgiaPHP vs SvelteKit Two very different tools‚Ä¶ with the same nostalgic goal: üëâ Make building websites feel simple again. üêò NostalgiaPHP No build step. PHP runs directly in Apache or Nginx. Markdown for content. Write files, save, done. File-based routing. Pages and collections map directly to the file system. Zero dependencies. Just PHP. No npm, no package-lock.json, no node_modules. Portable. Your project folder is the site. Move it, back it up, deploy it. üî• SvelteKit File-based routing. Drop files into src/routes, instant pages. SSR + client hydration. Modern interactivity with server-rendered performance. Build tooling. Vite, npm, adapters for deployment targets. Ecosystem. Rich integrations, plugins, and community support. Portable(ish). Your source folder is portable, but it requires a build to deploy. ‚ú® The Similarity Both exist because developers got tired of complex, overbuilt stacks. PHP in 2003: upload a file, refresh, instant site. SvelteKit in 2020s: create a route file, save, instant site (with hot reload). üöÄ The Difference NostalgiaPHP = caveman simple. Drop Markdown + PHP files, and you‚Äôve shipped a site. SvelteKit = modern simple. Rich app framework, but still needs Node, npm, builds, adapters. TL;DR If you want a content-heavy site that deploys in a minute: üëâ Make site. Files good. Framework bad. (NostalgiaPHP) If you want a modern interactive app with transitions, API routes, and full SPA feel: üëâ SvelteKit. Svelte logo ¬© Svelte contributors, used under CC-BY 4.0.","date":"2025-09-07"},{"type":"blog","url":"/blog/nostalgia-php-vs-wordpress","title":"NostalgiaPHP vs Early WordPress","desc":"A comparison of early WordPress and NostalgiaPHP‚Äìtwo content management systems with two different approaches.","text":"NostalgiaPHP vs Early WordPress Similarities PHP everywhere Early WordPress themes were just .php files mixing HTML + PHP. NostalgiaPHP does the same ‚Äî e.g. templates/main.php looks a lot like an old WP page.php or index.php. Front-matter / metadata WordPress always had the ‚Äúpost metadata‚Äù idea (title, date, slug). NostalgiaPHP uses YAML-like front-matter at the top of Markdown files. Templates + partials WP has header.php, footer.php, sidebar.php. NostalgiaPHP has partials/header.php, partials/footer.php. Same philosophy: break things into chunks for reuse. URL routing Early WP ‚Äúpretty permalinks‚Äù were powered by .htaccess rewrites to index.php. NostalgiaPHP does exactly that. Markdown vibe Early WordPress had a ‚Äúwrite in plain text, let PHP render it‚Äù feeling. NostalgiaPHP leans harder on Markdown instead of a WYSIWYG editor. Differences Database WordPress stores everything in MySQL (posts, pages, options). NostalgiaPHP stores everything as flat files (Markdown + front-matter). Admin panel Even in v1.0, WP had an admin dashboard for writing posts. NostalgiaPHP has no GUI ‚Äî you edit Markdown in your editor (like Astro or Jekyll). Extensibility WordPress was designed with plugins/hooks from the start. NostalgiaPHP is intentionally not extensible ‚Äî it‚Äôs minimal, ‚Äúwhat you see is what you get.‚Äù Ecosystem WP grew into a CMS/blogging empire with themes, plugins, hosting, etc. NostalgiaPHP is a micro-tool: no ecosystem, just simplicity. Scope creep WordPress evolved from ‚Äújust blogging‚Äù to ‚Äúcan power e-commerce + headless APIs + membership sites.‚Äù NostalgiaPHP is a time capsule ‚Äî it refuses to grow bloated, it stays small like early WP. TL;DR WordPress (early) = flat PHP templates + MySQL database + admin dashboard. NostalgiaPHP = flat PHP templates + Markdown files + no dashboard. If WP 1.0 felt like a ‚Äúpublishing tool for the everyman,‚Äù NostalgiaPHP is more like a ‚Äúpublishing tool for developers who miss the simplicity of 2004 but don‚Äôt want a database anymore.‚Äù","date":"2025-09-06"},{"type":"blog","url":"/blog/react-in-a-nutshell","title":"React in a Nutshell","desc":"This page shows you most of what you need to know to understand React.","text":"React in a Nutshell This page covers the essentials of React. A React component is simply a function that outputs HTML and manages its own state. Counter.jsx import { useState } from 'react' const Counter = (props) =&gt; { const [count, setCount] = useState(0) // Callbacks const dec = prev =&gt; prev - 1 const inc = prev =&gt; prev + 1 const zero = () =&gt; 0 return ( &lt;div&gt; &lt;p&gt;The count is {count}, &lt;strong&gt;{props.word}&lt;/strong&gt;.&lt;/p&gt; &lt;button onClick={() =&gt; setCount(dec)}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; setCount(inc)}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; setCount(zero)}&gt;Reset&lt;/button&gt; &lt;/div&gt; ) } export default Counter App.jsx (the root component) import Counter from './Counter.jsx' const App = () =&gt; ( &lt;&gt; &lt;Counter word=\"first\" /&gt; &lt;Counter word=\"second\" /&gt; &lt;/&gt; ) export default App","date":"2025-09-02"},{"type":"blog","url":"/blog/hello-world","title":"Hello World","desc":"The usual hello world post. Nothing much to see here.","text":"Hello World Welcome to the first post. Edit me at content/collections/blog/hello-world.md.","date":"2025-09-01"},{"type":"dox","url":"/dox/understanding-the-styles","title":"Understanding the Styles","desc":"When working with this site's stylesheets, it's helpful to understand how the CSS is organized to maintain clarity and scalability.","text":"Understanding the Styles When working with this site's stylesheets, it's helpful to understand how the CSS is organized to maintain clarity and scalability. The styles are broken down into five main files, each serving a distinct purpose: Stylesheet Overview reboot.css - This file contains baseline resets and foundational styles that normalize browser inconsistencies. Think of it as the groundwork that ensures a consistent look across browsers. colors.css - Colors.css serves as the color palette reference. It contains Tailwind-inspired CSS custom properties (tokens) such as --stone-100, --amber-200, and others. These tokens provide a consistent and reusable set of colors to choose from without having to generate colors on your own. skins.css - Skins.css holds design-specific tokens and themes. It defines the overall visual identity, including fonts, spacing, and other design tokens that can be customized or themed. utilities.css - Utilities.css contains layout primitives and helper classes (e.g., .wrapper, .flow, .inner, .auto-fit, .spread-apart) that are used repeatedly for structure and spacing across the site. These are not traditional Tailwind-style utilities but foundational classes for consistent layout. components.css - This file is dedicated to component-scoped styles. It uses CSS nesting to keep styles modular and encapsulated, making it easier to maintain and update individual UI components without affecting others. Philosophy The organization reflects a clear separation of style concerns: Baseline Resets (reboot.css): Establish a clean slate for styling by resetting default browser styles. Color Palette (colors.css): Provide a centralized and consistent set of color variables inspired by Tailwind CSS for easy theming and maintenance. Design Tokens &amp; Themes (skins.css): Define the visual language and theming elements. Utility Classes (utilities.css): Provide lightweight, single-purpose classes for quick layout or style adjustments without bloating component code. Component Styles (components.css): Encapsulate styles for individual components to promote modularity. By structuring these five stylesheets this way, developers can easily navigate, update, and extend the site's design system. If you are using this site as an example or starting point, following this pattern can help keep your CSS organized and scalable.","date":"2025-10-05"},{"type":"dox","url":"/dox/nostalgia-php-cli","title":"Nosty CLI ‚Äî Your New Best Friend","desc":"Scaffold posts and pages with a single command using the Nosty CLI helper.","text":"NostalgiaPHP CLI A tiny command-line helper for working with NostalgiaPHP sites. The CLI lives in the project root (nphp). Run it with PHP: php nphp &lt;command&gt; [args] Commands make:post Scaffold a new post in a collection. php nphp make:post &lt;collection&gt; &lt;slug&gt; [options] Options: --title=\"Custom Title\" ‚Üí Override default title --template=main ‚Üí Which front‚Äëmatter template (default: main) --date=YYYY-MM-DD ‚Üí Override date (default: today in site timezone) --draft ‚Üí Add draft: true to front matter --force ‚Üí Overwrite if file already exists Example: php nphp make:post blog hello-world --title=\"Hello World\" --draft make:page Scaffold a new standalone page. php nphp make:page &lt;slug&gt; [options] Same options as make:post. Example: php nphp make:page about --title=\"About Us\" backup Zip up your entire project into a timestamped archive. php nphp backup [--to=/absolute/path] If no --to is provided, backups go to ~/nosty_backups/&lt;project&gt;. Example: php nphp backup --to=\"$HOME/Dropbox/nosty_backups\" Build (SSG) Pre-render your site into static HTML (Static Site Generation). This command: Copies static/ into the output directory Each page is written to disk as {dir}/index.html so that users see clean URLs like /about instead of /about.html. Renders all collections (lists + individual items, with pagination) Fixes relative asset paths for portability Pre-renders dynamic routes like: /tags (list of all tags) /tag/{slug} (all items/pages for a tag) /sitemap.xml (auto-generated sitemap for search engines) /robots.txt (with a link to the sitemap) ‚ö†Ô∏è Limitations: Some pages cannot be safely pre-rendered. For example, the Contact page contains a live form that posts back to the same PHP route. Pre-rendering would freeze it into a static file, breaking submissions. To support forms on static hosting, you‚Äôd need to switch to a client-side submission method (JavaScript + API endpoint or a service like Netlify Forms). php nphp build [--out=dist] [--clean] Options: --out=dist ‚Üí Output directory (default: dist) --clean ‚Üí Remove existing output directory before building Examples: # Build into /dist php nphp build # Clean old build and output to /public php nphp build --out=public --clean Why It Matters The CLI helps you: Scaffold content quickly (posts, pages) Back up your entire project Pre-render your site for static hosting With build, you can host your NostalgiaPHP site anywhere ‚Äî Netlify, GitHub Pages, Vercel, S3 ‚Äî no PHP server required.","date":"2025-09-28"},{"type":"dox","url":"/dox/api-routes","title":"Introducing the NostalgiaPHP REST API","desc":"A minimal REST-style API for your flat-file content.","text":"Introducing the NostalgiaPHP REST API NostalgiaPHP has always been about simplicity: flat files, partial templates, and portable sites. Now there‚Äôs a new way to consume your content ‚Äî a minimal JSON API that makes your data available for JavaScript frontends, React components, mobile apps, or anything else that speaks HTTP. Available Routes The API lives under /api. Here are the routes currently available: /api ‚Äì overview of the available routes. /api/health ‚Äì quick check that the API is alive. /api/items ‚Äì list items from all collections. /api/items/blog ‚Äì list items from a specific collection. /api/pages ‚Äì list all pages. /api/pages/{slug} ‚Äì get a single page by slug. /api/tags ‚Äì list all tags across collections. /api/tags/{tag} ‚Äì list all items filtered by a tag. Responses are JSON, sorted by date (newest first when applicable), and include: { \"ok\": true, \"count\": 3, \"items\": [ { \"collection\": \"blog\", \"slug\": \"nostalgia-manifesto\", \"url\": \"/blog/nostalgia-manifesto\", \"title\": \"The NostalgiaPHP Manifesto\", \"date\": \"2025-09-12\", \"tags\": [\"intro\", \"php\"], \"html\": \"&lt;p&gt;Rendered HTML here...&lt;/p&gt;\" } ] } Filtering with Query Parameters The API also supports simple query parameters for finer control: By collection Instead of /api/items/blog, you can request: /api/items?collection=blog By tag To fetch only items with a certain tag: /api/items?tag=php Combine filters You can mix collection and tag filters: /api/items?collection=blog&amp;tag=nostalgia This makes it easy to pull exactly what you need, whether you‚Äôre building a blog feed, a tag cloud, or a project showcase. // Example: Fetching by tag in JavaScript fetch('/api/items?tag=php') .then(res =&gt; res.json()) .then(data =&gt; console.log(data.items)); CORS Allowlist By default, browsers enforce CORS rules when your frontend requests data from the API. NostalgiaPHP supports a configurable allowlist so you can explicitly permit which origins are allowed to fetch API data. In your config.php, set it like this: 'api' =&gt; [ 'enabled' =&gt; true, 'cors_allowlist' =&gt; [ 'https://svelte.dev', 'https://nostalgiaphp.onrender.com', // 'http://localhost:5173', // enable for local dev if needed ], ], This means only requests from those domains will receive the Access-Control-Allow-Origin header and succeed in the browser. Why It Matters Instead of scraping HTML or duplicating content, you can: Build a Svelte/React/Vue frontend that consumes your flat-file content. Create widgets that fetch recent blog posts. Use the API as a lightweight backend for apps. It‚Äôs REST-flavored, but intentionally minimal: GET requests only, JSON out. The rest is up to you. üöÄ Try it now: spin up php -S localhost:8000 and visit http://localhost:8000/api.","date":"2025-09-27"},{"type":"dox","url":"/dox/understanding-functions","title":"Understanding functions.php in NostalgiaPHP","desc":"A walkthrough of the helper functions that power routing, rendering, and content loading.","text":"Understanding functions.php One of the most important files in NostalgiaPHP is functions.php. It holds the core helper functions that make the whole system work ‚Äî from rendering templates to parsing Markdown. This post walks through each function and explains what it does. Path and URL Helpers normalize_path($path) Cleans up filesystem paths so they always use forward slashes. This makes things consistent across Windows, macOS, and Linux. config($key, $default) Fetches a configuration value from your global settings. Handy for site‚Äëwide options like the site name or base_url. site($key, $default) Shortcut to grab site‚Äëspecific config keys (name, description, etc.). path($key, $extra) Builds an absolute path inside the project. For example, path('templates') points to the templates folder. url($path) Generates a site URL. Useful for links inside templates so you don‚Äôt hard‚Äëcode the domain. request_path() Returns the current request path (e.g. /about). Used by the router to figure out what content to load. Content Helpers is_collection($dir) Checks if a directory looks like a collection (e.g. blog/ with multiple Markdown items). read_file($file) Reads a file into a string. A thin wrapper, but useful for consistency. parse_front_matter($text) Splits the front matter (the --- metadata block at the top of a Markdown file) from the body content. markdown_to_html($markdown) Turns Markdown into HTML. This is what lets you write posts in .md files and see them rendered on your site. load_page($slug) Loads a page by slug, looking in the content/pages directory. Returns both the front matter and the rendered HTML body. sanitize_rel_path($path) Ensures a relative path doesn‚Äôt contain ../ tricks. Prevents directory traversal vulnerabilities. load_page_path($file) Loads a page from a known file path instead of a slug. Similar output to load_page. load_collection_item($collection, $slug) Loads a single item from a collection (e.g. one blog post). list_collection($collection) Lists all items in a collection, sorted and parsed. This powers your collection index pages. excerpt_from_html($html, $length) Creates a text excerpt from HTML content, useful for previews on cards or lists. Templating Helpers nav_link($href, $label, $path) Builds a navigation link. Automatically adds an active class when the current page matches. is_active($href, $current_path, $prefix) Check if a navigation link should be marked \"active.\" active_class($href, $current_path, $prefix, $class) Return a CSS class if a link should be marked \"active.\" render($view, $vars) Renders a template from the templates/ folder. Variables like $title and $content are extracted for use inside the template. Tags (how NostalgiaPHP reads them) NostalgiaPHP treats tags as plain front-matter. You can write them as a CSV string: --- title: Example tags: php, simplicity, retro --- Internally, the tag pages scan Markdown files and read front matter via parse_front_matter(). They‚Äôre tolerant to: tags: or tag: (either works) casing (Tags, TAG, etc.) CSV strings or arrays an optional fallback key: keywords: Why keep these in one file? functions.php is small, fast, and easy to read. Every helper is: Global: Available everywhere in the project. Focused: Each does one simple job. Composable: You can combine them to build routes, load content, and render pages. This file is the glue that holds NostalgiaPHP together ‚Äî tiny, clear functions instead of a heavy framework. Next Steps Skim through functions.php yourself ‚Äî it‚Äôs less than a couple hundred lines. Try adding your own helper if you need something site‚Äëwide. Use the Dox collection to extend your own project documentation.","date":"2025-09-20"},{"type":"dox","url":"/dox/understanding-index","title":"Understanding index.php in NostalgiaPHP","desc":"A guided tour of the tiny front controller that routes requests, loads content, and renders templates.","text":"Understanding index.php In NostalgiaPHP, index.php is the front controller‚Äîthe single entry point that receives every request, figures out what the user wants, loads content, and renders the right template. This post walks through the core flow so you can extend it with confidence. 1. Normalize the request path $path = request_path(); // '/', '/about', '/blog/hello-world' $parts = $path === '/' ? [] : explode('/', ltrim($path, '/')); $first = $parts[0] ?? ''; request_path() strips the domain and query string. Home becomes [] for simpler branching. $first is the key decision point (e.g., blog, about). Tip: Keep this logic tiny and readable‚Äîmost routing bugs start here. 2. Handle special routes (system endpoints) Examples: robots.txt, sitemap.xml, admin. if ($path === '/robots.txt') { require __DIR__ . '/routes/robots.php'; exit; } if ($path === '/sitemap.xml') { require __DIR__.'/sitemap.php'; exit; } if ($path === '/admin') { // require __DIR__.'/auth/guard.php'; require_login(); require __DIR__.'/admin.php'; exit; } These bypass the normal content lookup entirely and loads the admin.php route. 3. Tag routes (cross-collection) Two tiny routes enable a global tag system: a. /tags ‚Äî list all tags with counts if ($path === '/tags') { require __DIR__ . '/routes/tags.php'; exit; } b. /tag/{slug} ‚Äî list items with a given tag if ($first === 'tag' &amp;&amp; isset($parts[1])) { require __DIR__ . '/routes/tag.php'; exit; } These run before the collection/page branches. They scan content/collections/*.md and content/pages/*.md, parse front matter, and match tags (or tag/keywords) case-insensitively. Rendering is intentionally minimal (a simple list), so you can swap it for cards later without touching the router. The tags.php or tag.php route is loaded. 4. Collection routes (/collection/slug) if (is_collection($first)) { require __DIR__ . '/routes/collections.php'; exit; } If $first is a collection in the config.php file ‚Üí load the collections.php route. 5. Page routes (/, /about, /about/blink) require __DIR__ . '/routes/pages.php'; If no other routes match, assume it is a page and load the pages.php route. 6. 404 fallback http_response_code(404); render('main', [ 'title' =&gt; 'Not Found', 'content' =&gt; '&lt;h1&gt;404&lt;/h1&gt;&lt;p&gt;Page not found.&lt;/p&gt;', 'path' =&gt; $path, ]); Each route will return a 404 page if the content is not fount. Design notes Small surface area: The router is just branching logic + a few helpers. No classes, no framework. Predictable structure: Pages live in content/pages, collections in content/collections/{name}. Pluggable views: Index pages use partials (cards-grid.php, items-list.php) so theme changes don‚Äôt touch routing. Security: Always run slugs through sanitize_rel_path() before hitting the filesystem. TL;DR index.php is intentionally tiny. It: Parses the path Short-circuits special routes Then tries collection Then tries home Falls back to a 404 page This clarity is the whole point of NostalgiaPHP: a site is just folders and files wired together with a few small functions.","date":"2025-09-20"},{"type":"dox","url":"/dox/getting-started","title":"Getting Started","desc":"The updated guide to getting started with NostalgiaPHP.","text":"Getting Started with NostalgiaPHP NostalgiaPHP is a caveman-simple, file-based CMS. No database. No build step. No framework. Just drop in some Markdown files, and you‚Äôre publishing. Requirements PHP 7.4+ (works on modern PHP versions) A web server with rewrites enabled (Apache .htaccess or Nginx try_files) That‚Äôs it. No Node, no npm, no Composer, no database. Quickstart (local dev) Clone or download the project: git clone https://github.com/bmehder/NostalgiaPHP.git cd NostalgiaPHP Start PHP‚Äôs built-in server: php -S localhost:8000 Open http://localhost:8000 in your browser. Project Structure nostalgia-php/ ‚îÇ‚îÄ‚îÄ routes/ # routing logic (pages, collections, admin, etc.) ‚îú‚îÄ‚îÄ content/ ‚îÇ ‚îú‚îÄ‚îÄ pages/ # static pages (Markdown) ‚îÇ ‚îî‚îÄ‚îÄ collections/ # groups like blog, docs ‚îú‚îÄ‚îÄ partials/ # header, footer, hero, card, etc. ‚îú‚îÄ‚îÄ templates/ # layouts (main, sidebar, admin) ‚îú‚îÄ‚îÄ static/ # css, images, js ‚îú‚îÄ‚îÄ config.php # site settings ‚îú‚îÄ‚îÄ functions.php # helpers ‚îú‚îÄ‚îÄ index.php # router entry point ‚îî‚îÄ‚îÄ ...other files # htaccess, dockerfile, Parsedown, README Pages live in content/pages/ as .md. Example: about.md ‚Üí /about Collections are folders under content/collections/. Example: content/collections/blog/hello-world.md ‚Üí /blog/hello-world Partials (partials/) are reusable chunks. Templates (templates/) define page layouts. Routes (app/routes/) handle how requests map to content. First Edits Change the site name in config.php: 'site' =&gt; [ 'name' =&gt; 'My First NostalgiaPHP Site', 'base_url' =&gt; '/', 'timezone' =&gt; 'America/New_York', ], Edit content/pages/about/index.md to change the about text. Add a new page: Create content/pages/sample/index.md: --- title: Sample Page description: Learn more about our team. --- # Sample Page We‚Äôre building simple sites with simple tools. Visit http://localhost:8000/sample. Add a new collection: Edit config.php and add a block like: 'collections' =&gt; [ 'team' =&gt; [ 'permalink' =&gt; '/team/{slug}', 'list_url' =&gt; '/team', 'sort' =&gt; ['date', 'desc'], ], ], Then add items under content/collections/team/. Deployment Apache: use the included .htaccess for pretty URLs. Nginx: add try_files $uri $uri/ /index.php?$query_string;. Permissions: make sure directories are 755 and files are 644. ‚úÖ That‚Äôs it ‚Äî edit Markdown, refresh the browser, and your site updates.","date":"2025-09-12"},{"type":"dox","url":"/dox/compatibility-contract","title":"Compatibility Contract","desc":"Compatibility contract in regards to Directory Structure and how to evolve code without breaking sites.","text":"Compatibility Contract Directory Structure content/pages/{slug}.md ‚Üí /slug (or / for index.md) content/collections/{name}/{slug}.md ‚Üí /{name}/{slug} static/ served at /static/... Front-matter keys (optional, don‚Äôt break if missing) Defaults (no surprises) If a key is missing, site still renders (infer title/desc or leave blank) Templates/partials API Templates receive: $title, $content, $meta, $path Partials inherit variables from callers; avoid renaming expected vars Upgrade Strategy (how to evolve code without breaking sites) No content migrations. Never require users to rename folders or files. Additive front-matter only. New keys are optional; old keys keep working. Graceful fallbacks. If a new feature is disabled/missing, render as before. Feature flags in config.php. (e.g., 'features' =&gt; ['sitemap_indexes' =&gt; true]) Semantic-ish versioning. Bump a version constant when behavior changes. Files you can swap safely functions.php ‚Äî new helpers, parsers, fallbacks. Keep function names/returns stable. index.php ‚Äî routing. Don‚Äôt change URL shapes; add new routes behind flags. config.php ‚Äî user merges. Provide defaults in functions.php so omissions don‚Äôt break.","date":"2025-09-11"},{"type":"dox","url":"/dox/quickstart-non-devs","title":"Quickstart for Non-Devs","desc":"How to do this for people that have no idea.","text":"ü™® NostalgiaPHP Quickstart for Non-Devs Make site. Fast. Files good. Framework bad. This is the fun way to edit a website ‚Äî no scary dashboards, no logins, just files and folders. Step 0. Get the Website Files Go to the project on GitHub: üëâ https://github.com/bmehder/NostalgiaPHP Click the green Code button, then click Download ZIP. When it finishes downloading, unzip it (double-click the .zip file). You‚Äôll now have a folder called NostalgiaPHP-main. Move this folder somewhere easy to find, like your Desktop or Documents. Step 1. Check if Your Computer Already Speaks PHP On Mac, open Terminal (in Applications ‚Üí Utilities). Type: php -v On Windows, Open Command Prompt (press Win + R, type cmd, then hit Enter). Type: php -v On either: If you see something like: PHP 8.2.12 (cli) ... üéâ You‚Äôre ready! Skip to Step 3. If you see command not found ‚Üí continue to Step 2. Step 2. Teach Your Computer PHP (one-time) On Mac, download this friendly little app: üëâ https://herd.laravel.com/ Open the installer, let it finish. Done. Your Mac speaks PHP now. On Windows, download this friendly little app: üëâ https://laragon.org/download Open the installer, let it finish. Done. Your PC speaks PHP now. ‚ÑπÔ∏è You won't be using the app you just installed, it is just the easiest way to install PHP on your computer. Step 3. Enter the Cave On Mac: Use Terminal to move into the project folder. Example: cd ~/Desktop/NostalgiaPHP (Change the path if you put the folder somewhere else.) On Windows: Use Command Prompt to move into the project folder. Example: cd JOHNDOE\\Desktop\\NostalgiaPHP (Change the path if you put the folder somewhere else, e.g. Documents\\NostalgiaPHP.) Step 4. Light the Fire üî• Still in Terminal (on Mac), or Command Prompt (on Windows), type: php -S localhost:8000 This means ‚Äúserve this folder at http://localhost:8000‚Äù. Step 5. Open Browser, See Magic ‚ú® Go to http://localhost:8000 in your favorite browser. That‚Äôs your site, live! Now edit any .md file in the content/ folder, save, refresh browser ‚Üí instant change. Cave Tips Stop the fire ‚Üí Press Ctrl + C in Terminal or Command Prompt to stop serving your site. Edit safely ‚Üí Markdown files are just text. You can use TextEdit (Mac) or Notepad (Windows) if you want ‚Äî they‚Äôll work, but everything looks like plain text. ‚ÑπÔ∏è For an easier time, download a free editor like VS Code (Mac/Windows) or Notepad++ (Windows). These highlight your code, which makes things easier. Don‚Äôt panic ‚Üí If a page disappears, you probably broke the --- front matter --- at the top. Fix it and reload. Backups ‚Üí Copy the folder. That‚Äôs it. üìù That‚Äôs all! Make site. Fast. Files good. Framework bad.","date":"2025-09-10"},{"type":"dox","url":"/dox/nostalgia-php-project-tour","title":"NostalgiaPHP ‚Äî Project Tour","desc":"A tour of the NostalgiaPHP project files.","text":"NostalgiaPHP ‚Äî Project Tour This is a tiny file‚Äëbased PHP CMS: Markdown in, HTML out. No database, no framework. Top-Level Files index.php ‚Äî Router. Reads the URL and decides whether to render a page, a collection list, or a collection item. functions.php ‚Äî Helpers: config, paths, URL building, front‚Äëmatter parsing, Markdown ‚Üí HTML, loaders, and render. config.php ‚Äî Site settings (name, timezone, base_url) and collection definitions. .htaccess ‚Äî Pretty URLs when using Apache in production (everything routes to index.php). Folders templates/ ‚Äî Layouts. main.php wraps every page with head/foot and includes partials. partials/ ‚Äî Reusable chunks. header.php and footer.php. content/ ‚Äî File‚Äëbased content. pages/ ‚Äî Static pages (e.g., about.md). URL is /{filename}. collections/ ‚Äî Named groups (e.g., blog/). Items are /{collection}/{slug}. static/ ‚Äî CSS, images, etc. Served as static files. Routing Flow (index.php) Parse the current request path. If / ‚Üí render content/pages/index.md. If /{collection} ‚Üí list items under content/collections/{collection}. If /{collection}/{slug} ‚Üí render that item. Else treat as a page: content/pages/{slug}.md. Template Flow Router prepares $title and $content (HTML). templates/main.php outputs HTML head, includes partials/header.php, dumps $content, and includes partials/footer.php. Content Files Each .md file can start with simple front‚Äëmatter followed by Markdown: --- title: Hello World date: 2025-09-01 draft: false --- # Heading Some **markdown** body text. Supported front‚Äëmatter keys are free-form; date is auto‚Äëcast to DateTime if YYYY-MM-DD. Collections Define collections in config.php: 'collections' =&gt; [ 'blog' =&gt; [ 'permalink' =&gt; '/blog/{slug}', 'list_url' =&gt; '/blog', 'sort' =&gt; ['date','desc'], ], ], Create items under content/collections/blog/*.md. The filename (without .md) is the slug unless overridden in front‚Äëmatter. Helpers Cheat Sheet (functions.php) site($key) ‚Äî read site config (e.g., site('name')). path($key) ‚Äî resolve paths: pages, collections, templates, partials. url($path) ‚Äî base‚Äëaware URL builder (works in subfolders). request_path() ‚Äî current URL path (e.g., about, blog/hello-world). load_page($slug) ‚Äî load content/pages/{slug}.md. list_collection($name) ‚Äî list items with meta for a collection. load_collection_item($name, $slug) ‚Äî load one item. render($view, $vars) ‚Äî include template with variables. Mental Model for WP Folks Think template hierarchy without the hierarchy: it‚Äôs all handled by index.php. Think Loop, but the ‚Äúquery‚Äù is a directory listing for a collection. Think the_content() being $content already HTML‚Äëified from Markdown. Menus are old‚Äëschool: edit partials/header.php by hand. Deploy Notes Apache: enable .htaccess as included. Nginx: route non‚Äëfile requests to index.php. Set correct base_url in config.php if serving from a subdirectory. Set permissions: directories 755, files 644.","date":"2025-09-02"}]}